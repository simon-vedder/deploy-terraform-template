# .github/workflows/terraform-plan.yml
name: 'Terraform Plan'

on:
  pull_request:
    branches: [ main ]
    paths:
      - 'terraform/**'
      - '.github/workflows/terraform-*.yml'
  workflow_dispatch:

permissions:
  id-token: write   # Required for Azure OIDC authentication
  contents: read
  pull-requests: write  # Required to comment on PRs

jobs:
  terraform-plan:
    name: 'Terraform Plan'
    runs-on: ubuntu-latest
    environment: 'DEV'
    strategy:
      matrix:
        environment: [dev] #, staging, prod]
      fail-fast: false
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.6.0
        terraform_wrapper: false

    - name: Azure Login via OIDC
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        # if you got different subscriptions (dev, staging, prod) you need to work with GitHub Environments to specifiy each subscription id secret

    - name: Install Security Tools
      run: |
        pip install checkov
        curl -s https://raw.githubusercontent.com/aquasecurity/tfsec/master/scripts/install_linux.sh | bash

    - name: Terraform Init
      run: |
        cd terraform/environments/${{ matrix.environment }}
        terraform init

    - name: Terraform Validate
      run: |
        cd terraform/environments/${{ matrix.environment }}
        terraform validate

    - name: Terraform Format Check
      run: |
        cd terraform/environments/${{ matrix.environment }}
        terraform fmt -check -recursive

    - name: Security Scan - Checkov
      run: |
        cd terraform/environments/${{ matrix.environment }}
        checkov -d . --framework terraform --output cli --skip-check CKV_AZURE_50
      continue-on-error: true

    - name: Security Scan - TFSec
      run: |
        cd terraform/environments/${{ matrix.environment }}
        tfsec .
      continue-on-error: true

    - name: Terraform Plan
      id: plan
      run: |
        cd terraform/environments/${{ matrix.environment }}
        terraform plan -no-color -out=tfplan
        terraform show -no-color tfplan > tfplan.txt

    - name: Update Pull Request with Plan
      uses: actions/github-script@v7
      if: github.event_name == 'pull_request'
      with:
        script: |
          const fs = require('fs');
          const environment = '${{ matrix.environment }}';
          const planPath = `terraform/environments/${environment}/tfplan.txt`;
          
          let planOutput = '';
          try {
            planOutput = fs.readFileSync(planPath, 'utf8');
          } catch (error) {
            planOutput = 'Plan file not found';
          }
          
          // Truncate plan if too long for GitHub comment
          if (planOutput.length > 60000) {
            planOutput = planOutput.substring(0, 60000) + '\n\n... (truncated)';
          }
          
          const commentBody = `## Terraform Plan Results - \`${environment}\`
          
          <details>
          <summary>ðŸ“‹ Show Plan</summary>
          
          \`\`\`hcl
          ${planOutput}
          \`\`\`
          
          </details>
          
          **Status:** ${{ steps.plan.outcome }}
          `;
          
          const { owner, repo } = context.repo;
          const pull_number = context.payload.pull_request.number;
          
          // Find existing comment
          const { data: comments } = await github.rest.issues.listComments({
            owner, repo, issue_number: pull_number,
          });
          
          const existingComment = comments.find(comment => 
            comment.body.includes(`Terraform Plan Results - \`${environment}\``)
          );
          
          if (existingComment) {
            await github.rest.issues.updateComment({
              owner, repo,
              comment_id: existingComment.id,
              body: commentBody
            });
          } else {
            await github.rest.issues.createComment({
              owner, repo,
              issue_number: pull_number,
              body: commentBody
            });
          }